@page "/carparks/{carparkid}"
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authorization
@using ParkNow.Models
@attribute [Authorize]
@inject IJSRuntime JSRuntime
@inject ICarparkService CarparkService
@inject IVehicleService VehicleService
@inject IBookingService BookingService
@inject IUserService UserService
@inject ISnackbar Snackbar
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ILogger<DynamicCarpark> Logger

<link rel="stylesheet" href="js/leaflet/leaflet.css" />
<script src="js/leaflet/leaflet.js"></script>
<style>
.mud-popover:has(.mud-picker) {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%,-50%) !important;
}
</style>

<div class="mt-8 d-flex justify-center align-center flex-column flex-grow-1 gap-4">
    <MudText class="mr-2"Typo="Typo.h6">
        @if (Carpark != null) {
            @("Carpark: " + carparkid)
        }
    </MudText>
    <MudText class="mr-2"Typo="Typo.h6">
        @if (Carpark != null) {
            @Carpark.Address 
        }
    </MudText>
    <div id="map" style="height: 325px;width: 325px;"> </div>
    <div style="@bookView">
        <EditForm FormName="book" Model="@model" OnValidSubmit="Book">
            <DataAnnotationsValidator/>
                <MudCard style="height: 300px;width: 325px;">
                    <MudCardContent>
                        <MudSelect @bind-Value="model.Vehicle" Placeholder="Select Vehicle" AdornmentIcon="@Icons.Material.Filled.DirectionsCarFilled" >
                            @foreach (Vehicle v in Vehicles) {
                                <MudSelectItem Value="@v.LicensePlate">@v.LicensePlate</MudSelectItem>
                            }
                        </MudSelect>
                        <div class="d-flex justify-center align-center flex-row flex-grow-1 gap-4 mt-3">
                            <div><MudText Typo="Typo.h6">Start</MudText></div>
                            <div><MudText Typo="Typo.h6">End</MudText></div>
                        </div>
                        <div class="d-flex justify-center align-center flex-row flex-grow-1 gap-4 mt-2">
                            <MudTimePicker Color="Color.Secondary" Time="@model.StartTime" MinuteSelectionStep="1" OpenTo="OpenTo.Minutes" TimeChanged="@(time => UpdateStartTime(time))"/>
                            <MudTimePicker Color="Color.Secondary" Time="@model.EndTime" MinuteSelectionStep="1" OpenTo="OpenTo.Minutes" TimeChanged="@(time => UpdateEndTime(time))"/>
                        </div>
                        <div class="d-flex justify-center align-center flex-row flex-grow-1 gap-4 mt-4">
                            <MudDatePicker Color="Color.Secondary" Date="@model.StartDate" DateChanged="@(date => UpdateStartDate(date))"/>
                            <MudDatePicker Color="Color.Secondary" Date="@model.EndDate" DateChanged="@(date => UpdateEndDate(date))"/>
                        </div>
                        <div><MudText Align="Align.Center" Typo="Typo.h6" class="mt-5">$@price</MudText></div>
                    </MudCardContent>
                    <MudCardActions>
                        <MudStaticButton FullWidth FormAction="FormAction.Submit" Variant="Variant.Filled" Color="Color.Secondary" Class="mb-2">Next</MudStaticButton>
                    </MudCardActions>
                </MudCard>
        </EditForm>
    </div>
    <div style="@payView">
        <MudCard style="height: 300px;width: 325px;">
            <MudCardContent>
                <MudTextField Mask="@(new PatternMask("0000 0000 0000 0000"))" Label="Credit Card Number" T="string" Variant="@Variant.Text" Clearable />
                <MudTextField Mask="@(new DateMask("MM/YY", 'Y', 'M'))" Label="Expires" T="string" Variant="@Variant.Text" />
                <MudTextField Mask="@(new PatternMask("000"))" Label="CVC" T="string" Variant="@Variant.Text" />
                <div><MudText Align="Align.Center" Typo="Typo.h6" class="mt-5">$@price</MudText></div>
            </MudCardContent>
            <MudCardActions>
                <MudButton FullWidth OnClick="Back" Variant="Variant.Filled" Color="Color.Secondary" Class="mr-2">Back</MudButton>
                <MudButton FullWidth OnClick="Pay" Variant="Variant.Filled" Color="Color.Secondary" Class="ml-2">Pay</MudButton>
            </MudCardActions>
        </MudCard>
    </div>
    <div style="@completedView">
        <MudCard style="height: 300px;width: 325px;">
            <MudCardContent>
                <div><MudText Align="Align.Center" Typo="Typo.h6" class="mt-5">Your booking has been confirmed!</MudText></div>
            </MudCardContent>
        </MudCard>
    </div>
</div>

<script>
    function initializeMap(lat, long) {
        var map = L.map('map', {
            center: [lat,long],
            zoom: 17
        });
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
        }).addTo(map); // Added tile layer for map rendering
        var marker = L.marker([lat,long]).addTo(map);
    }
</script>

@code {
    [Parameter]
    public required string carparkid { get; set; }
    public Carpark Carpark = null;
    private List<Vehicle> Vehicles = new List<Vehicle>();
    private decimal price = 0;
    private string? username;
    private string bookView = "display:block;";
    private string payView = "display:none;";
    private string completedView = "display:none;";

    [SupplyParameterFromForm]
    private BookingForm model { get; set; } = new();
    public class BookingForm
    {
        [Required]
        public string? Carpark { get; set; }

        [Required]
        public string? Vehicle { get; set; }
        public DateTime? StartDate { get; set; }

        public DateTime? EndDate { get; set; }
        public TimeSpan? StartTime { get; set; }

        public TimeSpan? EndTime { get; set; }

        public DateTime? GetStartDateTime()
        {
            return StartDate.HasValue && StartTime.HasValue
                ? StartDate.Value.Date + StartTime.Value
                : (DateTime?)null;
        }

        public DateTime? GetEndDateTime()
        {
            return EndDate.HasValue && EndTime.HasValue
                ? EndDate.Value.Date + EndTime.Value
                : (DateTime?)null;
        }
    }


    protected override async Task OnInitializedAsync() {
        Carpark = await CarparkService.GetCarpark(carparkid);

        var authState = await AuthenticationStateProvider
            .GetAuthenticationStateAsync();
        username = authState.User.Claims.FirstOrDefault(u => u.Type == ClaimTypes.Name)?.Value;
        if (!string.IsNullOrEmpty(username))
        {
            Vehicles = await VehicleService.GetUserVehicles(username);
            model.StartDate = DateTime.Now;
            model.StartTime = DateTime.Now.TimeOfDay;
            model.Carpark = carparkid;
        }
        else
        {
            // Handle the case where the username is null or empty
            Vehicles = new List<Vehicle>();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Carpark != null) // Ensure the map initializes only once
        {
            await RenderMap();
        }
    }

    private async Task RenderMap() {
        await JSRuntime.InvokeVoidAsync("initializeMap",Convert.ToDouble(Carpark.XCord),Convert.ToDouble(Carpark.YCord));
    }

    private async Task UpdateStartDate(DateTime? date) {
        model.StartDate = date;
        await UpdatePrice();
    }
    private async Task UpdateEndDate(DateTime? date) {
        model.EndDate = date;
        await UpdatePrice();
    }
    private async Task UpdateStartTime(TimeSpan? time) {
        model.StartTime = time;
        await UpdatePrice();
    }
    private async Task UpdateEndTime(TimeSpan? time) {
        model.EndTime = time;
        await UpdatePrice();
    }

    private async Task UpdatePrice() {
        var startDateTime = model.GetStartDateTime();
        var endDateTime = model.GetEndDateTime();

        if (startDateTime.HasValue && endDateTime.HasValue) // Ensure values are not null
        {
            price = await BookingService.CalculatePrice(startDateTime.Value, endDateTime.Value, Carpark);
        }
    }

    private void Book()
    {
        // Validate Booking
        if (!ValidateBooking())
        {
            return;
        }
        bookView = "display:none";
        payView = "display:block";
    }

    private async Task Pay() {
        // Add Booking
        Booking temp = new Booking{
            User = await UserService.GetUser(username),
            Carpark = Carpark,
            Vehicle = await VehicleService.GetVehicle(model.Vehicle),
            StartTime = model.GetStartDateTime(),
            EndTime = model.GetEndDateTime(),
            BookingTime = DateTime.Now,
            Cost = price,
            Status = Booking.Statuses.Active
        };
        Logger.LogInformation("Passed Booking");
        // Create New Booking Creates Payment as Well
        bool createsuccess = await BookingService.CreateNewBooking(temp);
        if (createsuccess) {
            Snackbar.Add("Booking successful!", Severity.Success);
            bookView = "display:none";
            payView = "display:none";
            completedView = "display:block";
        }
        else {
            Snackbar.Add("There is an error with your booking", Severity.Error);
        }
    }

    private void Back() {
        bookView = "display:block";
        payView = "display:none";
    }

    private bool ValidateBooking()
    {
        var errors = new List<string>();

        if (string.IsNullOrWhiteSpace(model.Vehicle))
        {
            errors.Add("Vehicle is required");
        }

        var startDateTime = model.GetStartDateTime();
        var endDateTime = model.GetEndDateTime();

        if (!startDateTime.HasValue)
        {
            errors.Add("Start date and time are required");
        }
        else if (startDateTime.Value <= DateTime.Now)
        {
            errors.Add("Start date and time must be in the future");
        }

        if (endDateTime == null)
        {
            errors.Add("End date and time are required");
        }
        else if (endDateTime.Value <= startDateTime.Value)
        {
            errors.Add("End date and time must be after the start date and time");
        }

        if (errors.Any())
        {
            foreach (var error in errors)
            {
                Snackbar.Add(error, Severity.Error);
            }
            return false;
        }

        return true;
    }
}
